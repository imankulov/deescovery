{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Deescovery Deescovery is a Python package that helps initialize modules of your Python projects on startup: Find and register blueprints in a Flask project. Automatically initialize Flask extensions. Find all SQLAlchemy models to make alembic happy. Find all FastAPI endpoints. Collect all Celery tasks. Initially designed to solve a specific problem of initializing Flask applications, it was made generic enough to work with any micro-framework or no framework at all. Micro-framework initialization problem Micro-framework-based projects are clean while they're small. Every micro-framework codebase I've seen, has a mess in the project initialization. With time, create_app() becomes filled with ad-hoc settings, imports-within-functions, and plug-in initializations. The Application Factory Pattern, proposed, for example, in the official Flask documentation , and the Flask Mega-Tutorial , legitimize this approach. The nature of create_app() leaves no place for the open-closed principle . We update this module every time we add a new plug-in, a new blueprint, or a new package. # myproject/__init__.py def create_app ( config_class = Config ): app = Flask ( __name__ ) app . config . from_object ( config_class ) db . init_app ( app ) migrate . init_app ( app , db ) login . init_app ( app ) mail . init_app ( app ) bootstrap . init_app ( app ) moment . init_app ( app ) babel . init_app ( app ) from myproject.errors import bp as errors_bp app . register_blueprint ( errors_bp ) from myproject.auth import bp as auth_bp app . register_blueprint ( auth_bp , url_prefix = '/auth' ) return app A common Flask application. The code is based on the Flask Mega-Tutorial. With deescovery , you can make the same code shorter, and remove the dependencies from implementation details. # file: myproject/app.py from flask import Flask from deescovery import discover from deescovery.flask import get_flask_rules def create_app (): flask_app = Flask ( __name__ ) flask_app . config . from_object ( \"myproject.config\" ) discover ( \"myproject\" , get_flask_rules ( \"myproject\" , flask_app )) return flask_app","title":"Home"},{"location":"#deescovery","text":"Deescovery is a Python package that helps initialize modules of your Python projects on startup: Find and register blueprints in a Flask project. Automatically initialize Flask extensions. Find all SQLAlchemy models to make alembic happy. Find all FastAPI endpoints. Collect all Celery tasks. Initially designed to solve a specific problem of initializing Flask applications, it was made generic enough to work with any micro-framework or no framework at all.","title":"Deescovery"},{"location":"#micro-framework-initialization-problem","text":"Micro-framework-based projects are clean while they're small. Every micro-framework codebase I've seen, has a mess in the project initialization. With time, create_app() becomes filled with ad-hoc settings, imports-within-functions, and plug-in initializations. The Application Factory Pattern, proposed, for example, in the official Flask documentation , and the Flask Mega-Tutorial , legitimize this approach. The nature of create_app() leaves no place for the open-closed principle . We update this module every time we add a new plug-in, a new blueprint, or a new package. # myproject/__init__.py def create_app ( config_class = Config ): app = Flask ( __name__ ) app . config . from_object ( config_class ) db . init_app ( app ) migrate . init_app ( app , db ) login . init_app ( app ) mail . init_app ( app ) bootstrap . init_app ( app ) moment . init_app ( app ) babel . init_app ( app ) from myproject.errors import bp as errors_bp app . register_blueprint ( errors_bp ) from myproject.auth import bp as auth_bp app . register_blueprint ( auth_bp , url_prefix = '/auth' ) return app A common Flask application. The code is based on the Flask Mega-Tutorial. With deescovery , you can make the same code shorter, and remove the dependencies from implementation details. # file: myproject/app.py from flask import Flask from deescovery import discover from deescovery.flask import get_flask_rules def create_app (): flask_app = Flask ( __name__ ) flask_app . config . from_object ( \"myproject.config\" ) discover ( \"myproject\" , get_flask_rules ( \"myproject\" , flask_app )) return flask_app","title":"Micro-framework initialization problem"},{"location":"anything_else/","text":"Usage with anything else When it comes to taming the chaos, opinionated structure and automated discovery can help. The package implements a so-called visitor pattern . You describe your application structure, outlining where you keep models, blueprints, controllers, etc. You define auto-discovery rules: what your initialization code does when it finds an object of a specific type. You let deescovery do the rest. It's specifically helpful for frameworks that define resources on the fly with decorators and expect you to import all necessary modules. For example, it can be helpful for Flask to load all your blueprints, initialize extensions, and import SQLAlchemy models. You can create your own discovery rules with the discover() function, ModuleRule and ObjectRule . Optionally, you can take advantage of custom matchers, defined in deescovery.matchers . For example, that's how you print all modules and all callable objects within the deescovery itself. from deescovery import discover , ModuleRule , ObjectRule module_printer = ModuleRule ( name = \"module printer\" , module_matches = lambda module_name : True , module_action = lambda module_name : print ( f \"Found module { module_name } \" ), ) object_printer = ObjectRule ( name = \"object printer\" , module_matches = lambda module_name : True , object_matches = callable , object_action = lambda obj : print ( f \"Found callable object { obj !r} \" ), ) discover ( \"deescovery\" , rules = [ module_printer , object_printer ])","title":"Usage with anything else"},{"location":"anything_else/#usage-with-anything-else","text":"When it comes to taming the chaos, opinionated structure and automated discovery can help. The package implements a so-called visitor pattern . You describe your application structure, outlining where you keep models, blueprints, controllers, etc. You define auto-discovery rules: what your initialization code does when it finds an object of a specific type. You let deescovery do the rest. It's specifically helpful for frameworks that define resources on the fly with decorators and expect you to import all necessary modules. For example, it can be helpful for Flask to load all your blueprints, initialize extensions, and import SQLAlchemy models. You can create your own discovery rules with the discover() function, ModuleRule and ObjectRule . Optionally, you can take advantage of custom matchers, defined in deescovery.matchers . For example, that's how you print all modules and all callable objects within the deescovery itself. from deescovery import discover , ModuleRule , ObjectRule module_printer = ModuleRule ( name = \"module printer\" , module_matches = lambda module_name : True , module_action = lambda module_name : print ( f \"Found module { module_name } \" ), ) object_printer = ObjectRule ( name = \"object printer\" , module_matches = lambda module_name : True , object_matches = callable , object_action = lambda obj : print ( f \"Found callable object { obj !r} \" ), ) discover ( \"deescovery\" , rules = [ module_printer , object_printer ])","title":"Usage with anything else"},{"location":"flask/","text":"Usage with Flask The initial purpose of the package was to serve as a discovery module for the opinionated Flask structure. Out of the box, the deescovery can do the following. Initialize services. The de-facto standard of initializing Flask extensions is to have classes with the method init_app() . The rules will scan top-level services.py of your application, find all the instances that have init_app() methods, and call obj.init_app(app=flask_app) for each of them. Initialize blueprints. Scan controllers.py, controllers_*.py and controllers/ to find Flask blueprints and attach them to the flask application. Initialize SQLALchemy. Import all files in models.py models_*.py and models/ to help flask-migrate find all the SQLAlchemy models to create migrations. Initialize all commands. Flask supports custom commands . The rules scan cli.py, cli_*.py and cli/ to find flask.cli.AppGroup instances and attach them to Flask's CLI. The function expects the following project structure. myproject app.py config.py services.py foo/ controllers.py models.py cli.py bar/ controllers.py models.py cli.py ... An example of your top-level app.py # file: myproject/app.py from flask import Flask from deescovery import discover from deescovery.flask import get_flask_rules def app () -> Flask : flask_app = Flask ( __name__ , instance_relative_config = True ) flask_app . config . from_object ( \"myproject.config\" ) flask_rules = get_flask_rules ( \"myproject\" , flask_app ) discover ( \"myproject\" , flask_rules ) return flask_app An example of your top-level services.py # file: myproject/services.py from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate from flask_mail import Mail db = SQLAlchemy () migrate = Migrate ( db = db ) mail = Mail ()","title":"Usage with Flask"},{"location":"flask/#usage-with-flask","text":"The initial purpose of the package was to serve as a discovery module for the opinionated Flask structure. Out of the box, the deescovery can do the following. Initialize services. The de-facto standard of initializing Flask extensions is to have classes with the method init_app() . The rules will scan top-level services.py of your application, find all the instances that have init_app() methods, and call obj.init_app(app=flask_app) for each of them. Initialize blueprints. Scan controllers.py, controllers_*.py and controllers/ to find Flask blueprints and attach them to the flask application. Initialize SQLALchemy. Import all files in models.py models_*.py and models/ to help flask-migrate find all the SQLAlchemy models to create migrations. Initialize all commands. Flask supports custom commands . The rules scan cli.py, cli_*.py and cli/ to find flask.cli.AppGroup instances and attach them to Flask's CLI. The function expects the following project structure. myproject app.py config.py services.py foo/ controllers.py models.py cli.py bar/ controllers.py models.py cli.py ... An example of your top-level app.py # file: myproject/app.py from flask import Flask from deescovery import discover from deescovery.flask import get_flask_rules def app () -> Flask : flask_app = Flask ( __name__ , instance_relative_config = True ) flask_app . config . from_object ( \"myproject.config\" ) flask_rules = get_flask_rules ( \"myproject\" , flask_app ) discover ( \"myproject\" , flask_rules ) return flask_app An example of your top-level services.py # file: myproject/services.py from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate from flask_mail import Mail db = SQLAlchemy () migrate = Migrate ( db = db ) mail = Mail ()","title":"Usage with Flask"},{"location":"install/","text":"","title":"Install"},{"location":"api/deescovery/","text":"Core API The primary API entrypoint is the deescovery.discover function. IRule Generic type for a discovery rule. Normally, you use one of its subclasses: ModuleRule or ObjectRule ModuleRule dataclass Do something with all modules matching the rule. For each module, found by deescovery.discover , the rule decides if it should be processed (calls module_matcher ), and if the result is positive, calls module_action . Example: Import all controllers.py of the project. from importlib import import_module from flask import Flask , Blueprint from deescovery import discover , ModuleRule from deescovery.matchers import MatchByPattern , MatchByType app = Flask ( __name__ ) controller_loader = ModuleRule ( name = \"Flask blueprints loader\" , module_matches = MatchByPattern ([ \"*.controllers\" ]), module_action = import_module , ) discover ( \"myapp\" , [ controller_loader ]) Attributes: Name Type Description name str the rule name. Used for logging purposes. module_matches Callable[[str], bool] a callable (function) that takes the module name and returns True if the module should be processed. You can write your own ad-hoc function, or use a deescovery.matchers.MatchByPattern class. module_action Callable[[str], Any] a callable (function) that takes the module name. The action will only be executed if the module matches the pre-condition of module_matches . The most common action is importing the module to execute its content. For example, you can use it to register all API controllers that the module contains and defines with decorators. ObjectRule dataclass Do something with all objects, matching the rules. For each module, found by deescovery.discover , the rule decides if the module should be processed (calls module_matches ). If the result is positive, the module is imported, and all its members are inspected with object_matches . If the returned value of the object matcher is also True, calls object_action . Example: Find all Flask blueprints in the files controllers.py of the project and register them in the Flask application. from flask import Flask , Blueprint from deescovery import discover , ObjectRule from deescovery.matchers import MatchByPattern , MatchByType app = Flask ( __name__ ) blueprints_loader = ObjectRule ( name = \"Flask blueprints loader\" , module_matches = MatchByPattern ([ \"*.controllers\" ]), object_matches = MatchByType ( Blueprint ), object_action = app . register_blueprint , ) discover ( \"myapp\" , [ blueprints_loader ]) Attributes: Name Type Description name str the rule name. Used for logging purposes. module_matches Callable[[str], bool] a callable (function) that takes the module name and returns True if objects of the module should be inspected further with object_matches . You can write your own ad-hoc function or use a deescovery.matchers.MatchByPattern class. object_matches Callable[[Any], bool] a callable (function) that takes the object and returns True if the object should be processed with object_action . You can write your own ad-hoc function or use one of the classes defined in the deescovery.matchers module. object_action Callable[[Any], Any] a callable (function) that takes the found object. The action will only be executed when the object's module pre-condition passes the module_matches test, and object itself passes the pre-condition of object_matches . discover ( import_path : str , rules : List [ deescovery . discovery . IRule ]) Discover all objects. Scan the package, find all modules and objects, matching the given set of rules, and apply actions defined in them. Parameters: Name Type Description Default import_path str top-level module name to start scanning. Usually, it's a name of your application, e.g., \"myapp\". If your application doesn't have a single top-level module, you will probably call it for all top-level modules. required rules List[deescovery.discovery.IRule] a list of module and objects rules. Each rule contains the match specification and the action, if the object matches. Normally, it's a list IRule subclasses: ModuleRule or ObjectRule . required","title":"Core API"},{"location":"api/deescovery/#core-api","text":"The primary API entrypoint is the deescovery.discover function.","title":"Core API"},{"location":"api/deescovery/#deescovery.discovery.IRule","text":"Generic type for a discovery rule. Normally, you use one of its subclasses: ModuleRule or ObjectRule","title":"IRule"},{"location":"api/deescovery/#deescovery.discovery.ModuleRule","text":"Do something with all modules matching the rule. For each module, found by deescovery.discover , the rule decides if it should be processed (calls module_matcher ), and if the result is positive, calls module_action . Example: Import all controllers.py of the project. from importlib import import_module from flask import Flask , Blueprint from deescovery import discover , ModuleRule from deescovery.matchers import MatchByPattern , MatchByType app = Flask ( __name__ ) controller_loader = ModuleRule ( name = \"Flask blueprints loader\" , module_matches = MatchByPattern ([ \"*.controllers\" ]), module_action = import_module , ) discover ( \"myapp\" , [ controller_loader ]) Attributes: Name Type Description name str the rule name. Used for logging purposes. module_matches Callable[[str], bool] a callable (function) that takes the module name and returns True if the module should be processed. You can write your own ad-hoc function, or use a deescovery.matchers.MatchByPattern class. module_action Callable[[str], Any] a callable (function) that takes the module name. The action will only be executed if the module matches the pre-condition of module_matches . The most common action is importing the module to execute its content. For example, you can use it to register all API controllers that the module contains and defines with decorators.","title":"ModuleRule"},{"location":"api/deescovery/#deescovery.discovery.ObjectRule","text":"Do something with all objects, matching the rules. For each module, found by deescovery.discover , the rule decides if the module should be processed (calls module_matches ). If the result is positive, the module is imported, and all its members are inspected with object_matches . If the returned value of the object matcher is also True, calls object_action . Example: Find all Flask blueprints in the files controllers.py of the project and register them in the Flask application. from flask import Flask , Blueprint from deescovery import discover , ObjectRule from deescovery.matchers import MatchByPattern , MatchByType app = Flask ( __name__ ) blueprints_loader = ObjectRule ( name = \"Flask blueprints loader\" , module_matches = MatchByPattern ([ \"*.controllers\" ]), object_matches = MatchByType ( Blueprint ), object_action = app . register_blueprint , ) discover ( \"myapp\" , [ blueprints_loader ]) Attributes: Name Type Description name str the rule name. Used for logging purposes. module_matches Callable[[str], bool] a callable (function) that takes the module name and returns True if objects of the module should be inspected further with object_matches . You can write your own ad-hoc function or use a deescovery.matchers.MatchByPattern class. object_matches Callable[[Any], bool] a callable (function) that takes the object and returns True if the object should be processed with object_action . You can write your own ad-hoc function or use one of the classes defined in the deescovery.matchers module. object_action Callable[[Any], Any] a callable (function) that takes the found object. The action will only be executed when the object's module pre-condition passes the module_matches test, and object itself passes the pre-condition of object_matches .","title":"ObjectRule"},{"location":"api/deescovery/#deescovery.discovery.discover","text":"Discover all objects. Scan the package, find all modules and objects, matching the given set of rules, and apply actions defined in them. Parameters: Name Type Description Default import_path str top-level module name to start scanning. Usually, it's a name of your application, e.g., \"myapp\". If your application doesn't have a single top-level module, you will probably call it for all top-level modules. required rules List[deescovery.discovery.IRule] a list of module and objects rules. Each rule contains the match specification and the action, if the object matches. Normally, it's a list IRule subclasses: ModuleRule or ObjectRule . required","title":"discover()"},{"location":"api/flask/","text":"Flask helpers Module for the Flask-specific rules. A sample Flask app generator would look like this. from flask import Flask from deescovery discover from deescovery.flask import get_flask_rules def app () -> Flask : flask_app = Flask ( __name__ ) flask_app . config . from_object ( \"myapp.config\" ) discovery_rules = get_flask_rules ( \"myapp\" , flask_app ) discover ( \"dashboards\" , discovery_rules ) return flask_app blueprints_loader ( import_path , flask_app ) Find and import all blueprints in the application. commands_loader ( import_path , flask_app ) Find all commands and register them as Flask CLI commands. generate_patterns ( import_path : str , module_prefix : str ) -> List [ str ] Generate a list of patterns to discover. For example, gen_patterns(\"myapp\", \"models\") generates patterns that make matchers discover the content in the following files. myapp/users/models.py myapp/invoices/models.py (etc. for all domain packages beyond \"users\" and \"invoices\") ... myapp/users/models_roles.py myapp/users/models_groups.py (etc. for all modules started with \"models_\" in all domain packages) ... myapp/users/models/roles.py myapp/users/models/groups.py (if you prefer nested structures) get_flask_rules ( import_path : str , flask_app ) -> List [ deescovery . discovery . IRule ] Return a list of rules useful for the Flask application. The following rules will be returned: Load SQLAlchemy models (files models.py) Load Flask blueprints (files controllers.py) Load Flask CLI commands (files cli.py) Initialize services (top-level file services.py) Parameters: Name Type Description Default import_path str name of the top-level module of the project (like, \"myproject\") required flask_app a Flask app instance. required Returns: Type Description List[deescovery.discovery.IRule] A list of rules, suitable to be passed to \"deescovery.discover()\" models_loader ( import_path ) Load all models. service_initializer ( import_path , flask_app ) Find and initialize all instances of Flask applications. Notice that the initialize scans for top-level services files, and doesn't walk over all your app's domain package.","title":"Flask helpers"},{"location":"api/flask/#flask-helpers","text":"Module for the Flask-specific rules. A sample Flask app generator would look like this. from flask import Flask from deescovery discover from deescovery.flask import get_flask_rules def app () -> Flask : flask_app = Flask ( __name__ ) flask_app . config . from_object ( \"myapp.config\" ) discovery_rules = get_flask_rules ( \"myapp\" , flask_app ) discover ( \"dashboards\" , discovery_rules ) return flask_app","title":"Flask helpers"},{"location":"api/flask/#deescovery.flask.blueprints_loader","text":"Find and import all blueprints in the application.","title":"blueprints_loader()"},{"location":"api/flask/#deescovery.flask.commands_loader","text":"Find all commands and register them as Flask CLI commands.","title":"commands_loader()"},{"location":"api/flask/#deescovery.flask.generate_patterns","text":"Generate a list of patterns to discover. For example, gen_patterns(\"myapp\", \"models\") generates patterns that make matchers discover the content in the following files. myapp/users/models.py myapp/invoices/models.py (etc. for all domain packages beyond \"users\" and \"invoices\") ... myapp/users/models_roles.py myapp/users/models_groups.py (etc. for all modules started with \"models_\" in all domain packages) ... myapp/users/models/roles.py myapp/users/models/groups.py (if you prefer nested structures)","title":"generate_patterns()"},{"location":"api/flask/#deescovery.flask.get_flask_rules","text":"Return a list of rules useful for the Flask application. The following rules will be returned: Load SQLAlchemy models (files models.py) Load Flask blueprints (files controllers.py) Load Flask CLI commands (files cli.py) Initialize services (top-level file services.py) Parameters: Name Type Description Default import_path str name of the top-level module of the project (like, \"myproject\") required flask_app a Flask app instance. required Returns: Type Description List[deescovery.discovery.IRule] A list of rules, suitable to be passed to \"deescovery.discover()\"","title":"get_flask_rules()"},{"location":"api/flask/#deescovery.flask.models_loader","text":"Load all models.","title":"models_loader()"},{"location":"api/flask/#deescovery.flask.service_initializer","text":"Find and initialize all instances of Flask applications. Notice that the initialize scans for top-level services files, and doesn't walk over all your app's domain package.","title":"service_initializer()"},{"location":"api/matchers/","text":"Matchers Module and object matchers. MatchByAttribute dataclass Object matcher that selects objects having an attribute with the given name. The same as lambda obj: hasattr(obj, attribute_name) Example: Find all objects that have an attribute init_app . MatchByAttribute ( \"init_app\" ) Attributes: Name Type Description attribute_name str attribute name as a string. MatchByMethod dataclass Object matcher that selects objects having a method with a specific name. Example: Find all objects having a method init_app() (a common way for initializing Flask plugins.) MatchByMethod ( \"init_app\" ) Attributes: Name Type Description method_name str method name as a string. MatchByPattern dataclass Module matcher that selects module names by patterns. Example: matcher = MatchByPattern ([ \"*.models\" , \"*.models.*\" ]) Attributes: Name Type Description patterns List[str] the list of Unix shell-style wildcards for module names. E.g. the following instance will match all files models.py and models/<something>.py in a flat list of packages inside your application. MatchBySubclass dataclass Object matcher that select classes that are subclasses of a given type. Almost the same as lambda obj: issubclass(obj, object_type) . Example: Find all Django models. from django.db import models matcher = MatchBySubclass ( models . Model ) Attributes: Name Type Description object_type Type a type or a tuple of types. MatchByType dataclass Object matcher that selects instances by their type. Same as lambda obj: isintance(obj, object_type) . Example: Find all Flask blueprints in a module. from flask import Blueprint matcher = MatchByType ( Blueprint ) Attributes: Name Type Description object_type Type object type or a list of types.","title":"Matchers"},{"location":"api/matchers/#matchers","text":"Module and object matchers.","title":"Matchers"},{"location":"api/matchers/#deescovery.matchers.MatchByAttribute","text":"Object matcher that selects objects having an attribute with the given name. The same as lambda obj: hasattr(obj, attribute_name) Example: Find all objects that have an attribute init_app . MatchByAttribute ( \"init_app\" ) Attributes: Name Type Description attribute_name str attribute name as a string.","title":"MatchByAttribute"},{"location":"api/matchers/#deescovery.matchers.MatchByMethod","text":"Object matcher that selects objects having a method with a specific name. Example: Find all objects having a method init_app() (a common way for initializing Flask plugins.) MatchByMethod ( \"init_app\" ) Attributes: Name Type Description method_name str method name as a string.","title":"MatchByMethod"},{"location":"api/matchers/#deescovery.matchers.MatchByPattern","text":"Module matcher that selects module names by patterns. Example: matcher = MatchByPattern ([ \"*.models\" , \"*.models.*\" ]) Attributes: Name Type Description patterns List[str] the list of Unix shell-style wildcards for module names. E.g. the following instance will match all files models.py and models/<something>.py in a flat list of packages inside your application.","title":"MatchByPattern"},{"location":"api/matchers/#deescovery.matchers.MatchBySubclass","text":"Object matcher that select classes that are subclasses of a given type. Almost the same as lambda obj: issubclass(obj, object_type) . Example: Find all Django models. from django.db import models matcher = MatchBySubclass ( models . Model ) Attributes: Name Type Description object_type Type a type or a tuple of types.","title":"MatchBySubclass"},{"location":"api/matchers/#deescovery.matchers.MatchByType","text":"Object matcher that selects instances by their type. Same as lambda obj: isintance(obj, object_type) . Example: Find all Flask blueprints in a module. from flask import Blueprint matcher = MatchByType ( Blueprint ) Attributes: Name Type Description object_type Type object type or a list of types.","title":"MatchByType"},{"location":"examples/ipython/","text":"IPython IPython is a Python console on steroids. It provides better command editing interface, history management, magic commands, and many more. IPython and deescovery can help you build a supercharged console, that is helpful for development and debugging. The deescovery package can help you find and import modules and classes of your project.","title":"IPython"},{"location":"examples/ipython/#ipython","text":"IPython is a Python console on steroids. It provides better command editing interface, history management, magic commands, and many more. IPython and deescovery can help you build a supercharged console, that is helpful for development and debugging. The deescovery package can help you find and import modules and classes of your project.","title":"IPython"},{"location":"examples/typer/","text":"Typer Typer is a library to build command-line interfaces. It supports commands and subcommands, and you may use Typer to create the extendable CLI API for your project, sort of like Django management commands. File myproject/app.py import typer from deescovery import discover , ObjectRule from deescovery.matchers import MatchByPattern , MatchByType typer_app = typer . Typer () rules = [ ObjectRule ( name = \"Typer CLI loader\" , module_matches = MatchByPattern ([ \"myproject.*.cli\" ]), object_matches = MatchByType ( typer . Typer ), object_action = lambda obj : typer_app . add_typer ( obj ), ), ] discover ( \"myproject\" , rules ) if __name__ == \"__main__\" : typer_app () Files that match the module pattern myproject.*.cli . For example, myproject/users/cli.py import typer app = typer . Typer ( name = \"users\" ) @app . command ( \"create\" ) def create ( name : str ): print ( f \"Creating { name } \" ) @app . command ( \"delete\" ) def delete ( name : str ): print ( f \"Deleting { name } \" ) This configuration creates the sub-command \"users\" with sub-sub-commands \"create\" and \"delete.\" python myproject/app.py users create Roman Creating Roman python myproject/app.py users delete Roman Deleting Roman","title":"Typer"},{"location":"examples/typer/#typer","text":"Typer is a library to build command-line interfaces. It supports commands and subcommands, and you may use Typer to create the extendable CLI API for your project, sort of like Django management commands. File myproject/app.py import typer from deescovery import discover , ObjectRule from deescovery.matchers import MatchByPattern , MatchByType typer_app = typer . Typer () rules = [ ObjectRule ( name = \"Typer CLI loader\" , module_matches = MatchByPattern ([ \"myproject.*.cli\" ]), object_matches = MatchByType ( typer . Typer ), object_action = lambda obj : typer_app . add_typer ( obj ), ), ] discover ( \"myproject\" , rules ) if __name__ == \"__main__\" : typer_app () Files that match the module pattern myproject.*.cli . For example, myproject/users/cli.py import typer app = typer . Typer ( name = \"users\" ) @app . command ( \"create\" ) def create ( name : str ): print ( f \"Creating { name } \" ) @app . command ( \"delete\" ) def delete ( name : str ): print ( f \"Deleting { name } \" ) This configuration creates the sub-command \"users\" with sub-sub-commands \"create\" and \"delete.\" python myproject/app.py users create Roman Creating Roman python myproject/app.py users delete Roman Deleting Roman","title":"Typer"}]}