{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Roman Discovery Background Micro-framework-based projects are clean while they're small. Every micro-framework codebase I've seen suffer from the same problem: a mess in the project initialization module. Sooner or later, your entry point package becomes a soup of ad-hoc environment reads, imports-within-functions, and plug-in initializations. The infamous create_app() is a boiling broth where architectural rules, dependencies, and common sense don't exist. The core of The Application Factory Pattern, proposed, for example, in the official Flask documentation , and the Flask Mega-Tutorial , legitimize this pattern. It would be OK to keep that ugly, primordial mess hidden behind a layer of abstraction, but the primitive nature of create_app() leaves no place for the open-closed principle . We need to get back to this module every time we add a new plug-in, a new blueprint, or a new package. Discovery to the rescue When it comes to taming the chaos, opinionated structure and automated discovery can help. You describe your application structure, outlining where you keep models, blueprints, controllers, etc. You define auto-discovery rules: what your initialization code does when it finds an object of a specific type. You let roman-discovery do the rest. It's specifically helpful for frameworks that define resources on the fly with decorators and expect you to import all necessary modules. For example, it can be helpful for Flask to load all your blueprints, initialize extensions, and import SQLAlchemy models. Visitor pattern is the best name for the approach you like finding patterns in implementation details. Install pip install roman-discovery Glossary I find it helpful to add some semantic colors to the packages and modules of the app. For this, I introduce the terms \"domain package\" and \"module role.\" Domain package -- one of the multiple top-level packages of the application that contains the business logic. Adepts of domain-driven design would define domain packages as containers to encapsulate bounded contexts . Module Role -- a group of modules or packages (directories with __init__.py files) used for the same purpose. I prefer express roles with module prefixes or second-level packages. For example, files models_users.py and models_groups.py can have the \"Models\" role and keep your model definitions, and files controllers_users.py and controller_groups.py can have the \"Controllers\" role and keep the code for your controllers. Usage with Flask Using within the opinionated Flask structure was the initial purpose of the package. Use roman_discovery.discover() with roman_discovery.flask.get_flask_rules() . The function expects the following project structure. myproject app.py config.py services.py # Simple flat structure with one module # per role in a domain package. foo/ controllers.py models.py cli.py # Flat structure with multiple modules per # role in a domain package. Modules of the same # role share the same prefix bar/ controllers_api.py controllers_admin.py models_users.py models_projects.py cli_users.py cli_projects.py # Nested structure with one flat package per role baz/ controllers/ api.py admin.py models/ users.py projects.py cli/ users.py projects.py With this structure, it will do the following. Scan controllers.py, controllers_*.py and controllers/ to find blueprints and attach the blueprints to the flask application. Import all files in models.py models_*.py and models/ to help flask-migrate find all the SQLAlchemy models to create migrations. Scan cli.py, cli_*.py and cli/ to find flask.cli.AppGroup instances and attach them to Flask's CLI. Scan top-level services.py, find all the instances that have init_app() methods, and call obj.init_app(app=flask_app) for each of them. An example of your top-level app.py # file: myproject/app.py from flask import Flask from roman_discovery import discover from roman_discovery.flask import get_flask_rules def app () -> Flask : flask_app = Flask ( __name__ , instance_relative_config = True ) flask_app . config . from_object ( \"myproject.config\" ) flask_rules = get_flask_rules ( \"myproject\" , flask_app ) discover ( \"myproject\" , flask_rules ) return flask_app An example of your top-level services.py # file: myproject/services.py from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate from flask_mail import Mail db = SQLAlchemy () migrate = Migrate ( db = db ) mail = Mail () Usage with anything else You can create your own discovery rules with the discover() function, ModuleRule and ObjectRule . Optionally, you can take advantage of custom matchers, defined in roman_discovery.matchers . For example, that's how you print all modules and all callable objects within the roman_discovery itself. from roman_discovery import discover , ModuleRule , ObjectRule module_printer = ModuleRule ( name = \"module printer\" , module_matches = lambda module_name : True , module_action = lambda module_name : print ( f \"Found module { module_name } \" ), ) object_printer = ObjectRule ( name = \"object printer\" , module_matches = lambda module_name : True , object_matches = callable , object_action = lambda obj : print ( f \"Found callable object { obj !r} \" ), ) discover ( \"roman_discovery\" , rules = [ module_printer , object_printer ]) Why the \"roman\" prefix? I use it as my own \"pseudo-namespace.\" If I ever abandon the project, at least the package doesn't occupy a common name.","title":"Home"},{"location":"#roman-discovery","text":"","title":"Roman Discovery"},{"location":"#background","text":"Micro-framework-based projects are clean while they're small. Every micro-framework codebase I've seen suffer from the same problem: a mess in the project initialization module. Sooner or later, your entry point package becomes a soup of ad-hoc environment reads, imports-within-functions, and plug-in initializations. The infamous create_app() is a boiling broth where architectural rules, dependencies, and common sense don't exist. The core of The Application Factory Pattern, proposed, for example, in the official Flask documentation , and the Flask Mega-Tutorial , legitimize this pattern. It would be OK to keep that ugly, primordial mess hidden behind a layer of abstraction, but the primitive nature of create_app() leaves no place for the open-closed principle . We need to get back to this module every time we add a new plug-in, a new blueprint, or a new package.","title":"Background"},{"location":"#discovery-to-the-rescue","text":"When it comes to taming the chaos, opinionated structure and automated discovery can help. You describe your application structure, outlining where you keep models, blueprints, controllers, etc. You define auto-discovery rules: what your initialization code does when it finds an object of a specific type. You let roman-discovery do the rest. It's specifically helpful for frameworks that define resources on the fly with decorators and expect you to import all necessary modules. For example, it can be helpful for Flask to load all your blueprints, initialize extensions, and import SQLAlchemy models. Visitor pattern is the best name for the approach you like finding patterns in implementation details.","title":"Discovery to the rescue"},{"location":"#install","text":"pip install roman-discovery","title":"Install"},{"location":"#glossary","text":"I find it helpful to add some semantic colors to the packages and modules of the app. For this, I introduce the terms \"domain package\" and \"module role.\" Domain package -- one of the multiple top-level packages of the application that contains the business logic. Adepts of domain-driven design would define domain packages as containers to encapsulate bounded contexts . Module Role -- a group of modules or packages (directories with __init__.py files) used for the same purpose. I prefer express roles with module prefixes or second-level packages. For example, files models_users.py and models_groups.py can have the \"Models\" role and keep your model definitions, and files controllers_users.py and controller_groups.py can have the \"Controllers\" role and keep the code for your controllers.","title":"Glossary"},{"location":"#usage-with-flask","text":"Using within the opinionated Flask structure was the initial purpose of the package. Use roman_discovery.discover() with roman_discovery.flask.get_flask_rules() . The function expects the following project structure. myproject app.py config.py services.py # Simple flat structure with one module # per role in a domain package. foo/ controllers.py models.py cli.py # Flat structure with multiple modules per # role in a domain package. Modules of the same # role share the same prefix bar/ controllers_api.py controllers_admin.py models_users.py models_projects.py cli_users.py cli_projects.py # Nested structure with one flat package per role baz/ controllers/ api.py admin.py models/ users.py projects.py cli/ users.py projects.py With this structure, it will do the following. Scan controllers.py, controllers_*.py and controllers/ to find blueprints and attach the blueprints to the flask application. Import all files in models.py models_*.py and models/ to help flask-migrate find all the SQLAlchemy models to create migrations. Scan cli.py, cli_*.py and cli/ to find flask.cli.AppGroup instances and attach them to Flask's CLI. Scan top-level services.py, find all the instances that have init_app() methods, and call obj.init_app(app=flask_app) for each of them. An example of your top-level app.py # file: myproject/app.py from flask import Flask from roman_discovery import discover from roman_discovery.flask import get_flask_rules def app () -> Flask : flask_app = Flask ( __name__ , instance_relative_config = True ) flask_app . config . from_object ( \"myproject.config\" ) flask_rules = get_flask_rules ( \"myproject\" , flask_app ) discover ( \"myproject\" , flask_rules ) return flask_app An example of your top-level services.py # file: myproject/services.py from flask_sqlalchemy import SQLAlchemy from flask_migrate import Migrate from flask_mail import Mail db = SQLAlchemy () migrate = Migrate ( db = db ) mail = Mail ()","title":"Usage with Flask"},{"location":"#usage-with-anything-else","text":"You can create your own discovery rules with the discover() function, ModuleRule and ObjectRule . Optionally, you can take advantage of custom matchers, defined in roman_discovery.matchers . For example, that's how you print all modules and all callable objects within the roman_discovery itself. from roman_discovery import discover , ModuleRule , ObjectRule module_printer = ModuleRule ( name = \"module printer\" , module_matches = lambda module_name : True , module_action = lambda module_name : print ( f \"Found module { module_name } \" ), ) object_printer = ObjectRule ( name = \"object printer\" , module_matches = lambda module_name : True , object_matches = callable , object_action = lambda obj : print ( f \"Found callable object { obj !r} \" ), ) discover ( \"roman_discovery\" , rules = [ module_printer , object_printer ])","title":"Usage with anything else"},{"location":"#why-the-roman-prefix","text":"I use it as my own \"pseudo-namespace.\" If I ever abandon the project, at least the package doesn't occupy a common name.","title":"Why the \"roman\" prefix?"},{"location":"api/","text":"discovery IRule Generic type for a rule. ModuleRule dataclass Module rule. Defines a rule 'Run for all modules matching '. ObjectRule dataclass Object rule. Defines a rule 'Run for all objects matching inside modules matching '. discover ( import_path , rules ) Discover all objects. Scan the package, find all modules and objects, matching the given set of rules, and apply actions defined in them. Parameters: Name Type Description Default import_path str top-level module name to start scanning. Usually, it's a name of your application, e.g., \"myapp\". If your application doesn't have a single top-level module, you will probably call it for all top-level modules. required rules List[roman_discovery.discovery.IRule] a list of module and objects rules. Each rule contains the match specification and the action, if the object matches. required flask Module for the Flask-specific rules. A sample Flask app generator would look like this. from flask import Flask from roman_discovery discover from roman_discovery.flask import get_flask_rules def app () -> Flask : flask_app = Flask ( __name__ ) flask_app . config . from_object ( \"myapp.config\" ) discovery_rules = get_flask_rules ( \"myapp\" , flask_app ) discover ( \"dashboards\" , discovery_rules ) return flask_app blueprints_loader ( import_path , flask_app ) Find and import all blueprints in the application. commands_loader ( import_path , flask_app ) Find all commands and register them as Flask CLI commands. generate_patterns ( import_path , module_prefix ) Generate a list of patterns to discover. For example, gen_patterns(\"myapp\", \"models\") generates patterns that make matchers discover the content in the following files. myapp/users/models.py myapp/invoices/models.py (etc. for all domain packages beyond \"users\" and \"invoices\") ... myapp/users/models_roles.py myapp/users/models_groups.py (etc. for all modules started with \"models_\" in all domain packages) ... myapp/users/models/roles.py myapp/users/models/groups.py (if you prefer nested structures) get_flask_rules ( import_path , flask_app ) Return a list of rules useful for the Flask application. The following rules will be returned: Load SQLAlchemy models (files models.py) Load Flask blueprints (files controllers.py) Load Flask CLI commands (files cli.py) Initialize services (top-level file services.py) Parameters: Name Type Description Default import_path str name of the top-level module of the project (like, \"myproject\") required flask_app a Flask app instance. required Returns: Type Description List[roman_discovery.discovery.IRule] A list of rules, suitable to be passed to \"roman_discovery.discover()\" models_loader ( import_path ) Load all models. service_initializer ( import_path , flask_app ) Find and initialize all instances of Flask applications. Notice that the initialize scans for top-level services files, and doesn't walk over all your app's domain package. matchers List of generic matchers. MatchByAttribute dataclass Object matcher that selects having an attribute with the given name. Constructor accepts an attribute name as a string. E.g., the following instance will find all objects that have an attribute init_app (a common way for initializing Flask plugins.) MatchByAttribute(\"init_app\") MatchByCallableAttribute dataclass Object matcher that selects having a callable attribute with the given name. Constructor accepts an attribute name as a string. E.g., the following instance will find all objects having a method init_app() (a common way for initializing Flask plugins.) MatchByCallableAttribute(\"init_app\") MatchByPattern dataclass Module matcher that selects module names by patterns. Constructor accepts the list of Unix shell-style wildcards for module names. E.g. the following instance will match all files \"models.py\" and \"models/ .py\" in a flat list of packages inside your application. matcher = MatchByPattern([\"*.models\", \"*.models.*\"]) MatchByType dataclass Object matcher that selects instances by type. Constructor accepts a type or a tuple of types. E.g., the following instance will find all Flask blueprints in a module. from flask import Blueprint matcher = MatchByType(Blueprint)","title":"API"},{"location":"api/#roman_discovery.discovery","text":"","title":"discovery"},{"location":"api/#roman_discovery.discovery.IRule","text":"Generic type for a rule.","title":"IRule"},{"location":"api/#roman_discovery.discovery.ModuleRule","text":"Module rule. Defines a rule 'Run for all modules matching '.","title":"ModuleRule"},{"location":"api/#roman_discovery.discovery.ObjectRule","text":"Object rule. Defines a rule 'Run for all objects matching inside modules matching '.","title":"ObjectRule"},{"location":"api/#roman_discovery.discovery.discover","text":"Discover all objects. Scan the package, find all modules and objects, matching the given set of rules, and apply actions defined in them. Parameters: Name Type Description Default import_path str top-level module name to start scanning. Usually, it's a name of your application, e.g., \"myapp\". If your application doesn't have a single top-level module, you will probably call it for all top-level modules. required rules List[roman_discovery.discovery.IRule] a list of module and objects rules. Each rule contains the match specification and the action, if the object matches. required","title":"discover()"},{"location":"api/#roman_discovery.flask","text":"Module for the Flask-specific rules. A sample Flask app generator would look like this. from flask import Flask from roman_discovery discover from roman_discovery.flask import get_flask_rules def app () -> Flask : flask_app = Flask ( __name__ ) flask_app . config . from_object ( \"myapp.config\" ) discovery_rules = get_flask_rules ( \"myapp\" , flask_app ) discover ( \"dashboards\" , discovery_rules ) return flask_app","title":"flask"},{"location":"api/#roman_discovery.flask.blueprints_loader","text":"Find and import all blueprints in the application.","title":"blueprints_loader()"},{"location":"api/#roman_discovery.flask.commands_loader","text":"Find all commands and register them as Flask CLI commands.","title":"commands_loader()"},{"location":"api/#roman_discovery.flask.generate_patterns","text":"Generate a list of patterns to discover. For example, gen_patterns(\"myapp\", \"models\") generates patterns that make matchers discover the content in the following files. myapp/users/models.py myapp/invoices/models.py (etc. for all domain packages beyond \"users\" and \"invoices\") ... myapp/users/models_roles.py myapp/users/models_groups.py (etc. for all modules started with \"models_\" in all domain packages) ... myapp/users/models/roles.py myapp/users/models/groups.py (if you prefer nested structures)","title":"generate_patterns()"},{"location":"api/#roman_discovery.flask.get_flask_rules","text":"Return a list of rules useful for the Flask application. The following rules will be returned: Load SQLAlchemy models (files models.py) Load Flask blueprints (files controllers.py) Load Flask CLI commands (files cli.py) Initialize services (top-level file services.py) Parameters: Name Type Description Default import_path str name of the top-level module of the project (like, \"myproject\") required flask_app a Flask app instance. required Returns: Type Description List[roman_discovery.discovery.IRule] A list of rules, suitable to be passed to \"roman_discovery.discover()\"","title":"get_flask_rules()"},{"location":"api/#roman_discovery.flask.models_loader","text":"Load all models.","title":"models_loader()"},{"location":"api/#roman_discovery.flask.service_initializer","text":"Find and initialize all instances of Flask applications. Notice that the initialize scans for top-level services files, and doesn't walk over all your app's domain package.","title":"service_initializer()"},{"location":"api/#roman_discovery.matchers","text":"List of generic matchers.","title":"matchers"},{"location":"api/#roman_discovery.matchers.MatchByAttribute","text":"Object matcher that selects having an attribute with the given name. Constructor accepts an attribute name as a string. E.g., the following instance will find all objects that have an attribute init_app (a common way for initializing Flask plugins.) MatchByAttribute(\"init_app\")","title":"MatchByAttribute"},{"location":"api/#roman_discovery.matchers.MatchByCallableAttribute","text":"Object matcher that selects having a callable attribute with the given name. Constructor accepts an attribute name as a string. E.g., the following instance will find all objects having a method init_app() (a common way for initializing Flask plugins.) MatchByCallableAttribute(\"init_app\")","title":"MatchByCallableAttribute"},{"location":"api/#roman_discovery.matchers.MatchByPattern","text":"Module matcher that selects module names by patterns. Constructor accepts the list of Unix shell-style wildcards for module names. E.g. the following instance will match all files \"models.py\" and \"models/ .py\" in a flat list of packages inside your application. matcher = MatchByPattern([\"*.models\", \"*.models.*\"])","title":"MatchByPattern"},{"location":"api/#roman_discovery.matchers.MatchByType","text":"Object matcher that selects instances by type. Constructor accepts a type or a tuple of types. E.g., the following instance will find all Flask blueprints in a module. from flask import Blueprint matcher = MatchByType(Blueprint)","title":"MatchByType"}]}